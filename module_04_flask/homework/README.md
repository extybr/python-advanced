# Практическая работа 4
## Цели практической работы
- Познакомиться с GET- и POST-запросами.
- Научиться добавлять валидаторы и тестировать их.
- Закрепить навык отправки запросов через Postman.

## Что входит в практическую работу
1. Валидаторы. Добавление.
2. Валидаторы. Создание.
3. Валидаторы. Тестирование.
4. Время работы системы.
5. Текущие процессы.

## Задача 1. Валидаторы. Добавление
### Что нужно сделать
В endpoint `/registration` добавьте все валидаторы, о которых говорилось в последнем видео:

1) email (текст, обязательно для заполнения, валидация формата);
2) phone (число, обязательно для заполнения, длина — десять символов, только положительные числа);
3) name (текст, обязательно для заполнения);
4) address (текст, обязательно для заполнения);
5) index (только числа, обязательно для заполнения);
6) comment (текст, необязательно для заполнения).
### Советы и рекомендации
- Все валидаторы из модуля `wtforms.validators` могут принимать в качестве аргумента параметр `message` — сообщение в случае ошибки валидации. Эти сообщения можно получить как у формы `errors_list = form.errors`, так и у конкретного поля `email_errors_list = form.email.errors`.
### Что оценивается
- Учитывается обязательность или опциональность полей.
- В email есть валидация формата.
- В phone есть валидация по типу данных и длине.
- В index есть валидация по типу данных.

## Задача 2. Валидаторы. Создание
### Что нужно сделать
Довольно неудобно использовать встроенный валидатор `NumberRange` для ограничения числа по его длине. Создадим свой для поля phone.<br>
По своей сути валидатор — это функция, которая на вход принимает форму и поле, а в случае ошибки валидации выкидывает `ValidationError`.

```python
def number_length(form: FlaskForm, field: Field):
    if ...:
        raise ValidationError

number = IntegerField(validators=[InputRequired(), number_length])
```

Также можно реализовать его с помощью класса:

```python
class NumberLength:
    def __call__(self, form: FlaskForm, field: Field):
        if ...:
            raise ValidationError

number = IntegerField(validators=[InputRequired(), NumberLength()])
```

Создайте валидатор обоими способами. Валидатор должен принимать на вход параметры `min` и `max` — минимальная и максимальная длина, а также опциональный параметр `message` (см. рекомендации к предыдущему заданию).
### Советы и рекомендации
- Чтобы функциональный валидатор мог принимать параметры, саму функцию нужно декорировать:
    ```python
    def number_length(min: int, max: int, message: Optional[str] = None):
        def _number_length(form: FlaskForm, field: Field):
            if ...:
                raise ValidationError
    
        return _number_length
    ```

### Что оценивается
- Валидатор создан как на основе функции, так и на основе класса.
- Валидатор принимает параметры `min`, `max` и `message`.
- Корректно обрабатывается длина числа.

## Задача 3. Валидаторы. Тестирование
### Что нужно сделать
Для каждого поля и валидатора в endpoint `/registration` напишите юнит-тест, который проверит корректность работы валидатора. Таким образом, нужно проверить, что существуют наборы данных, которые проходят валидацию, и такие, которые валидацию не проходят.
### Советы и рекомендации
- Тестировать форму можно с помощью тестового клиента Flask, посылая POST-запросы к endpointу.
### Что оценивается
- Для каждого поля написано хотя бы два теста: проходящий и не проходящий валидацию.
- Тестируется «защита от дурака» — реакция программы на очевидно неверные действия человека.
- Для тестирования flask-приложения используется тестовый клиент.

## Задача 4. Время работы системы
### Что нужно сделать
Напишите GET-endpoint `/uptime`, который в ответ на запрос будет выводить строку вида `f"Current uptime is {UPTIME}"`, где `UPTIME` — uptime системы (показатель того, как долго текущая система не перезагружалась).

Сделать это можно с помощью команды `uptime`. 
### Советы и рекомендации
- Наберите в терминале `man uptime`, чтобы узнать больше об этой команде. Может быть, у неё есть полезные флаги.
### Что оценивается
- uptime возвращается в виде времени, без лишней информации.
## Задача 5. Текущие процессы
### Что нужно сделать
Напишите GET-endpoint `/ps`, который принимает на вход аргументы командной строки, а возвращает результат работы команды `ps` с этими аргументами. 
Входные значения endpoint должен принимать в виде списка через аргумент `arg`.

Например, для исполнения команды `ps aux` запрос будет следующим:

`/ps?arg=a&arg=u&arg=x`
### Советы и рекомендации
- Получить аргументы списком можно следующим образом:
    ```
    args: list[str] = request.args.getlist('arg')
    ```
- Хорошая практика — заключение потенциально небезопасного пользовательского ввода в кавычки с помощью `shlex.quote`:
    ```jupyterpython
    >>> user_cmd = '; ./kill_the_system.sh'
    >>> f"ps {user_cmd}"
    ps ; ./kill_the_system.sh
    
    >>> clean_user_cmd = shlex.quote(user_cmd)
    >>> f"ps {clean_user_cmd}"
    ps '; ./kill_the_system.sh'
    ```
    В первом случае выполнится команда `ps`, а затем зловещий скрипт.<br>
    Во втором же случае ничего страшного не произойдёт.
- Чтобы красиво отформатировать результат, заключите его в тег <br>`<pre>Your result</pre>`.
### Что оценивается
- Аргументы передаются списком, а не строкой.
- Общие советы и рекомендации
- [Документация WTForms](https://wtforms.readthedocs.io/en/3.0.x/).
- Вызвать программу из Python можно с помощью модуля `subprocess`:
    ```jupyterpython
    >>> import shlex, subprocess
    >>> command_str = f"uptime"
    >>> command = shlex.split(command_str)
    >>> result = subprocess.run(command, capture_output=True)
    ```

## Что оценивается в практической работе
- В ответ на невалидные данные сервер возвращает список ошибок.
- Запуск веб-сервера происходит в блоке __main__.
