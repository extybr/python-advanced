# Практическая работа 5
В практической работе есть обязательные и дополнительные задачи.

_Обязательные задачи_ помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.

_Дополнительные задачи_ выполнять необязательно. Они подойдут тем, кто хочет ещё немного потренироваться, решая задачи по программированию. Вы также можете отправить их на проверку и получить обратную связь от куратора.

## Цель практической работы
Научиться:

- запускать процессы и управлять ими из Python;
- создавать свои контекстные менеджеры;
- перенаправлять потоки stdout и stderr.
## Что входит в практическую работу
Обязательные задачи:

1. Освобождение порта.
2. Удалённое исполнение кода.
3. Заглушка исключений.
4. Перенаправление вывода.

Дополнительная задача:

5. Самопечать.

## Задача 1. Освобождение порта
### Что нужно сделать
Консольная утилита lsof (**L**i**s**t **O**pen **F**iles) выводит информацию о том, какие файлы используют какие-либо процессы. Эта команда может рассказать много интересного, так как в Unix-подобных системах всё является файлом.

Но нам пока нужна лишь одна из её возможностей.<br>
Запуск `lsof -i :port` выдаст список процессов, занимающих введённый порт.<br>
Например, `lsof -i :5000`.

Как мы с вами выяснили, наш сервер отказывается запускаться, если кто-то занял его порт. Напишите функцию, которая на вход принимает порт и запускает по нему сервер. Если порт будет занят, она должна найти процесс по этому порту, завершить его и попытаться запустить сервер ещё раз.

### Советы и рекомендации
- Чтобы завершить процесс, можно воспользоваться функцией [os.kill()](https://docs.python.org/3.10/library/os.html#os.kill).
### Что оценивается
- Завершается только нужный процесс.

## Задача 2. Удалённое исполнение кода
### Что нужно сделать
Напишите endpoint, который принимает на вход код на Python (строка) и тайм-аут в секундах (положительное число не больше 30). Пользователю возвращается результат работы программы, а если время, отведённое на выполнение кода, истекло, то процесс завершается, после чего отправляется сообщение о том, что исполнение кода не уложилось в данное время.

Тесты к заданию обязательны.
### Советы и рекомендации
- Чтобы запустить код, используйте такой синтаксис:

`python -c "code"`

Например, `python -c "print('Hello world!')"`
- Для выполнения задания рекомендуется использовать метод [Popen.communicate](https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate).
- Чем может грозить использование параметра s`hell=True`:
```jupyterpython
>>>  code = 'print()"; echo "hacked'
>>> cmd = f'python -c "{code}"'
>>> Popen(cmd, shell=True)
<Popen: returncode: None args: 'python -c "print()"; echo "hacked"'>
>>>
hacked
```
- Однако есть ещё одна проблема — мы можем запустить сторонний процесс в самом коде:  
```shell
$ python -c "
from subprocess import run
run(['./kill_the_system.sh'])
"
Hello from kill_the_system.sh
```
Чтобы защититься от этого, нужно наложить ограничения на ресурсы, которые может использовать запускаемая программа. Сделать это можно с помощью встроенной утилиты `prlimit`:

```shell
$ prlimit --nproc=1:1 python -c "
from subprocess import run
run(['./kill_the_system.sh'])
"
BlockingIOError: [Errno 11] Resource temporarily unavailable
```
### Что оценивается
- Endpoint принимает POST-запрос.
- Используется FlaskForm с валидаторами для полей.
- Написаны тесты для следующих случаев:
  - Тайм-аут ниже, чем время исполнения.
  - Некорректно введённые данные в форме.
  - Небезопасный ввод в поле с кодом (проверка на `shell=True`).

## Задача 3. Заглушка исключений
### Что нужно сделать
Реализуйте контекстный менеджер, который будет игнорировать переданные типы исключений, возникающие внутри блока with. Если выкидывается неожидаемый тип исключения, то он прокидывается выше.

Тесты к заданию обязательны.
#### Пример 1
**Код**
```python
err_types = {ZeroDivisionError, TypeError}
with BlockErrors(err_types):
    a = 1 / 0
print('Выполнено без ошибок')
```
**Вывод**
```
Выполнено без ошибок
```
#### Пример 2
**Код**
```python
err_types = {ZeroDivisionError}
with BlockErrors(err_types):
    a = 1 / '0'
print('Выполнено без ошибок')
```
**Вывод**
```
TypeError: unsupported operand type(s) for /: 'int' and 'str'
```
#### Пример 3
**Код**
```python
outer_err_types = {TypeError}
with BlockErrors(outer_err_types):
    inner_err_types = {ZeroDivisionError}
    with BlockErrors(inner_err_types):
        a = 1 / '0'
    print('Внутренний блок: выполнено без ошибок')
print('Внешний блок: выполнено без ошибок')
```
**Вывод**
```
Внешний блок: выполнено без ошибок
```
#### Пример 4
**Код**
```python
err_types = {Exception}
with BlockErrors(err_types):
    a = 1 / '0'
print('Выполнено без ошибок')
```

**Вывод**
```
Выполнено без ошибок
```
### Что оценивается
- Написаны тесты для следующих случаев:
  - Ошибка игнорируется.
  - Ошибка прокидывается выше.
  - Ошибка прокидывается выше во внутреннем блоке и игнорируется во внешнем.
  - Дочерние ошибки игнорируются.

## Задача 4. Перенаправление вывода
### Что нужно сделать
Иногда возникает необходимость перенаправить вывод в нужное нам место внутри программы по ходу её выполнения. Реализуйте контекстный менеджер, который принимает два IO-объекта (например, открытые файлы) и перенаправляет туда стандартные потоки stdout и stderr. 

Аргументы контекстного менеджера должны быть непозиционными, чтобы можно было ещё перенаправить только stdout или только stderr.

Тесты к заданию обязательны.

#### Пример
**Код**
```python
print('Hello stdout')
stdout_file = open('stdout.txt', 'w')
stderr_file = open('stderr.txt', 'w')

with Redirect(stdout=stdout_file, stderr=stderr_file):
    print('Hello stdout.txt')
    raise Exception('Hello stderr.txt')

print('Hello stdout again')
raise Exception('Hello stderr')
```

**Стандартный поток**
```
Hello stdout
Hello stdout again
Traceback (most recent call last):
  File "/home/wignorbo/tmp", line 30, in <module>
    raise Exception('Hello stderr')
Exception: Hello stderr
```

**stdout.txt**
```
Hello stdout.txt
```

**stderr.txt**
```
Traceback (most recent call last):
  File "/home/wignorbo/tmp", line 27, in <module>
    raise Exception('Hello stderr.txt')
Exception: Hello stderr.txt
```
### Советы и рекомендации
- [Интерфейс класса IOBase](https://docs.python.org/3/library/io.html#io.IOBase).
- В ходе тестирования могут возникнуть конфликты из-за перехвата стандартного потока вывода. Чтобы этого избежать, результаты юнит-тестов можно перенаправить, например, так:
    ```python
    if __name__ == '__main__':
        with open('test_results.txt', 'a') as test_file_stream:
            runner = unittest.TextTestRunner(stream=test_file_stream)
            unittest.main(testRunner=runner)
    ```
- Чтобы вывести полный текст ошибки, понадобится модуль traceback:
    ```python
    import traceback
    sys.stderr.write(traceback.format_exc())
    ```
### Что оценивается
- В тестах проверяется, что информация действительно была перенаправлена в другой поток вывода.
- При инициализации контекстного менеджера сохраняются предыдущие значения `sys.stdout` и `sys.stderr`. При использовании `sys.__stdout__` и `sys.__stderr__` могут не работать вложенные блоки.
- Учтены случаи использования контекстного менеджера без аргументов или только с одним аргументом — `stdout` или `stderr`.

## Задача 5. Самопечать (выполните по желанию)
### Что нужно сделать
Напишите код, который выводит сам себя.<br>
Обратите внимание, что скрипт может быть расположен в любом месте.

**self_printing.py**
```python
result = 0
for n in range(1, 11):
    result += n ** 2

% Secret magic code %
```

**$ python self_printing.py**
```
result = 0
for n in range(1, 11):
    result += n ** 2

% Secret magic code %
```

## Общие советы и рекомендации
- [Описание конструкции with](https://docs.python.org/3/reference/compound_stmts.html#with)
- [Shell injection](https://en.wikipedia.org/wiki/Code_injection#Shell_injection)
## Что оценивается в практической работе
- Названия переменных и функций имеют значащие имена.
- Тестовые случаи (`unittest.TestCase`) и наборы тестов (тестирующие функции) имеют значащие имена.
- При работе с процессами учитывается безопасность их исполнения.
