# Практическая работа, модуль 12

## Цели практической работы

* Потренироваться в использовании пулов потоков и процессов в Python.
* Познакомиться с базовым механизмом работы GIL и научиться выбирать нужный тип многозадачности в зависимости от
  поставленной задачи.

## Что входит в практическую работу

1. «Звёздные войны 2».
2. Анализ процессов.
3. Прерывание программы.
4. Сортировка логов.

## Задача 1. «Звёздные войны 2»

### Что нужно сделать

Перепишите задачу 2 из предыдущего модуля с использованием объекта типа `Pool` из модуля `multiprocessing`. Напомним
условие: скачайте 20 персонажей [из базы данных о «Звёздных войнах»](https://swapi.dev/) и сохраните их имена, возраст и
пол в БД.

Оформите решение в виде двух функций: с использованием `Pool` и `ThreadPool`.

Замерьте время работы каждой из них и сравните результаты.

### Советы и рекомендации

* Чтобы получить результат запроса, обратитесь к методу `json()` объекта `Response`.
* Заметьте, что количество потоков не ограничивается количеством ядер.
* Посмотрите, как меняется скорость выполнения в зависимости от количества процессов и потоков. Почему так происходит?

### Что оценивается

* Решение оформлено в виде двух отдельных функций: с использованием пула потоков и пула процессов.
* Время работы замеряется в коде.
* Информация о персонажах записывается в БД.

## Задача 2. Анализ процессов

### Что нужно сделать

Реализуйте две функции:

```python
def process_count(username: str) -> int:
    # количество процессов, запущенных из-под 
    # текущего пользователя username
    pass
```

```python
def total_memory_usage(root_pid: int) -> float:
    # суммарное потребление памяти древа процессов 
    # с корнем root_pid в процентах
    pass
```

### Советы и рекомендации

* Для решения вам пригодятся флаги `-u`, `-o` и `--ppid` [команды ps](https://man7.org/linux/man-pages/man1/ps.1.html).
* [Утилита pgrep](https://man7.org/linux/man-pages/man1/pgrep.1.html).
* Используйте максимум возможностей терминальных команд и минимум вычислений в самой программе. Это сильно повысит
  производительность. Например, для подсчёта строк отлично
  подходит [команда wc](https://www.opennet.ru/man.shtml?topic=wc&category=1&russian=2).

### Что оценивается

* При подсчёте строк не учитывается заголовок.
* Подсчитывается потребление памяти не только процесса, но и всех его потомков.

## Задача 3. Прерывание программы

### Что нужно сделать

Внесите изменения в следующую программу так, чтобы её можно было прервать с помощью `Ctrl+C`, корректно завершив потоки `t1` и `t2`:

```python
from threading import Semaphore, Thread
import time

sem: Semaphore = Semaphore()


def fun1():
    while True:
        sem.acquire()
        print(1)
        sem.release()
        time.sleep(0.25)


def fun2():
    while True:
        sem.acquire()
        print(2)
        sem.release()
        time.sleep(0.25)


t1: Thread = Thread(target=fun1)
t2: Thread = Thread(target=fun2)
try:
    t1.start()
    t2.start()
except KeyboardInterrupt:
    print('\nReceived keyboard interrupt, quitting threads.')
    exit(1)
```

### Советы и рекомендации

Вероятно, в интернете вы найдёте много вариантов решения этой задачи. Выберите несколько и подумайте, какой из них лучше
и почему.

### Что оценивается

* Функции `fun1()` и `fun2()` не претерпели изменений.
* При нажатии `Ctrl+C` программа завершает работу потоков.

## Задача 4. Сортировка логов

### Что нужно сделать

Одна из классических проблем при работе с многопоточными и многопроцессорными программами — организация записи в файл.

Реализуйте следующую программу:

* с интервалом в одну секунду запускаются последовательно десять потоков;
* каждый поток работает 20 секунд;
* каждый поток должен один раз в секунду писать лог в файл в формате `<timestamp> <дата>`.

Получите дату с `http://127.0.0.1:8080/timestamp/1549892280`, запустив перед этим `server.py`.

Вместо 1549892280 подставьте текущий `timestamp`.

Логи должны быть отсортированы по `timestamp`.

### Советы и рекомендации

* Текущий `timestamp` можно получить с помощью
  модуля [datetime](https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp)
  или [time](https://docs.python.org/3/library/time.html#time.time).
* Рекомендуем воспользоваться структурой данных [Queue](https://docs.python.org/3/library/queue.html).

### Что оценивается

* Логи не сортируются перед записью в файл.
* Потоки получают `timestamp` непосредственно перед запросом на сайт.
* Потоки завершают работу спустя 20 секунд.
* Записи в файле отсортированы по `timestamp`.
* Используются потоки, а не процессы.

## Что оценивается в практической работе

* Названия переменных, функций и классов имеют значащие имена.
* Использование общих ресурсов происходит в блоке синхронизации доступа.
* Для решения IO-bound-задач используются потоки.
* Для решения CPU-bound-задач используется процессы.
