## Практическая работа 7
### Цель практической работы
Научиться:
* конфигурировать логгеры с помощью:
  * ОПП подхода,
  * словаря,
  * ini-файла;
* писать собственные обработчики и фильтры;
* использовать класс Formatter для форматирования логов.

### Что входит в практическую работу
1. Добавляем логирование.
2. ООП-конфигурация.
3. Многоуровневый обработчик.
4. dict-конфигурация.
5. Ротация логов.
6. Дерево логгеров.
7. Только ASCII.
8. Сборщик логов.
9. ini-конфигурация.

## Задача 1. Добавляем логирование
### Что нужно сделать

Мы подготовили небольшое приложение — консольный калькулятор для двух чисел. Однако в нём нет нормального логирования, сейчас там только print’ы.

Создайте логгер в каждом модуле (app и utils) и добавьте вместо вызова print логирование с подходящим по смыслу уровнем.

### Что оценивается
Логгер в каждом модуле имеет соответствующее имя.

## Задача 2. ОПП-конфигурация
### Что нужно сделать
Добавьте в приложение выше функцию, которая будет конфигурировать логирование с помощью `basicConfig`. Обработчик должен выводить логи в стандартный поток вывода (stdout). 

Также добавьте форматирование с помощью класса `Formatter` ко всем обработчикам в таком виде:

`уровень | логгер | время | номер строки | сообщение`

### Что оценивается
* Созданный обработчик выводит логи в stdout, а не в stderr.
* Форматирование происходит с помощью класса Formatter.


## Задача 3. Многоуровневый обработчик
### Что нужно сделать
Если логов много, неудобно смотреть большой файл с мешаниной записей. Наведём порядок.

Добавьте handler, который будет писать сообщения разных уровней в соответствующие файлы. Например, сообщения уровня debug попадут в файл `calc_debug.log`, а уровня error — в `calc_error.log`.

Не забудьте добавить инициализацию нового обработчика в функцию из предыдущей задачи.

### Советы и рекомендации
Метод `emit` обработчика принимает в качестве аргумента объект типа [LogRecord](https://docs.python.org/3/library/logging.html#logrecord-attributes), который содержит всю необходимую информацию о логе.

### Что оценивается
Обработчик направляет лог в соответствующий его уровню файл.


## Задача 4. dict-конфигурация
### Что нужно сделать
Функция конфигурирования прилично разрослась и выглядит не слишком опрятно. Перепишите конфигурацию на декларативный манер с помощью словаря и вынесите её в отдельный файл. 

Примените в функции эту конфигурацию, закомментировав предыдущий код.

Советы и рекомендации
* [Схема конфигурации с помощью словаря](https://docs.python.org/3/library/logging.config.html#configuration-dictionary-schema)
* Применить dict-конфигурацию можно так:
  ```python
  logging.config.dictConfig(dict_config)
  ```

### Что оценивается
* dict-конфигурация вынесена в отдельный файл.
* Созданный обработчик также добавляется через словарь.

## Задача 5. Ротация логов
### Что нужно сделать
Сделайте так, чтобы логгер utils писал все сообщения уровня INFO и выше в файл *utils.log* и хранил записи только за последние 10 часов.

Убедитесь, что в выводе нет записей от других логгеров.

### Советы и рекомендации
* Посмотрите [документацию имеющихся обработчиков](https://docs.python.org/3/library/logging.handlers.html#baserotatinghandler).  Какой из них подойдёт лучше для решения данной задачи — `BaseRotatingHandler`, `RotatingFileHandler` или `TimedRotatingFileHandler`?
* Проверьте на маленьких интервалах, например 10 секунд, чтобы убедиться, что ротация работает.
* Чтобы не наплодить много лог-файлов, можно воспользоваться параметром `backupCount`, отвечающим за количество резервных копий.

### Что оценивается
* Сообщения от других логгеров не выводятся.
* Выводятся логи только уровня INFO и выше.
* В файле хранятся записи только за последние 10 часов.


## Задача 6. Дерево логгеров
### Что нужно сделать
Иногда разобраться в хитрой иерархии логгеров бывает затруднительно. Специально для таких целей добрые люди написали библиотеку [logging_tree](https://pypi.org/project/logging_tree/), которая выводит древовидную структуру всех существующих логгеров.

Запустите и посмотрите, как выглядит каждый logger. Результат запишите в файл `logging_tree.txt`.
### Что оценивается
* Выведена полная структура логгеров.
* Результат работы записан в файл.


## Задача 7. Только ASCII
### Что нужно сделать
Мы не рассмотрели, как реализованы объекты класса `Filter` в логировании и как ими пользоваться, по двум причинам:

1. Это не такая частая задача.
2. Это отличный повод для практики в работе с документацией :)

Итак, задание: прочитайте [документацию об объекте Filter](https://docs.python.org/3/library/logging.html#filter-objects).

Реализуйте собственный фильтр, который будет отсеивать сообщения, содержащие не ASCII-символы в тексте. Например, такие: `ÎŒØ∏‡°⁄·°€йцукен`

### Советы и рекомендации
* В Python 3.7 была добавлена функция `str.isascii()`, возвращающая булево значение, которое показывает, все ли символы строки входят в ASCII.
* Ради интереса попробуйте реализовать свою функцию `is_ascii`, которая принимает на вход строку, а возвращает также булево значение.
* Для получения всех ASCII-символов можно воспользоваться модулем [string](https://docs.python.org/3/library/string.html#string-constants).
### Что оценивается
* ASCII-фильтр добавлен в dict-конфигурацию.
* Сообщения, содержащие не ASCII-символы, не показываются в логах.


## Задача 8. Сборщик логов
### Что нужно сделать
Как правило, работая с распределёнными приложениями, приходится решать вопрос с централизованной обработкой логов. Реализуйте Flask-сервер, содержащий два endpoint: первый будет принимать логи от сервисов, а второй будет их отображать.

### Советы и рекомендации
* Для реализации можно воспользоваться [HTTPHandler](https://docs.python.org/3/library/logging.handlers.html#httphandler). Пример создания обработчика:

    ```python
    HTTPHandler(host='127.0.0.1:3000', url='/log', method='POST')
    ```
    
    Лог отправляется на заданный хост с помощью POST-запроса в виде формы. Обработать его на сервере можно так:
    
    ```python
    from flask import request
    
    @app.route('/log', methods=['POST'])
    def log():
        print(request.form)
        return 'OK', 200
    ```

- Можно создать собственный обработчик и использовать знакомую вам утилиту `curl` с помощью модуля `subprocess`. Но мы настоятельно рекомендуем способ, описанный выше.


### Что оценивается
* Логи обрабатываются от нескольких сервисов.
* Написанный обработчик добавлен в dict-конфигурацию.
* Логи принимаются через POST-запрос.
* Логи можно получить через GET-запрос.
* Не показываются лишние логи, например от urllib.


## Задача 9. ini-конфигурация
### Что нужно сделать
Когда вам придётся работать в проекте не с нуля, высока вероятность того, что логирование в нём будет сконфигурировано не через словарь, а через ini-файл. Так что хорошо бы научиться в нём ориентироваться. Он устроен не очень сложно. 

В репозитории приведён пример ini-файла. Ваша задача — переписать его в формат dict-конфигурации.

Опционально: напишите программу, которая конвертирует ini-файл в словарь.

### Советы и рекомендации
* Применить ini-конфигурацию можно так:
  ```python
  logging.config.fileConfig('logging_conf.ini')
  ```
* [Документация по ini-конфигурации](https://docs.python.org/3/library/logging.config.html#configuration-file-format)
  
### Что оценивается
Полученная dict-конфигурация идентична исходной.

## Общие советы и рекомендации
* Есть возможность обновлять конфигурацию во время выполнения программы через сервер конфигурации. Как это сделать, можно прочитать [в документации](https://docs.python.org/3.10/howto/logging-cookbook.html#configuration-server-example).
* Конфигурацию логирования можно задать с помощью YAML и любого другого формата, конвертируемого в JSON, который, в свою очередь, переводится в словарь:
  
  ```python
  import logging.config
  import yaml
  
  with open('./logging_conf.yml', 'r') as stream:
    config = yaml.load(stream, Loader=yaml.FullLoader)
  
  logging.config.dictConfig(config)
  ```

## Что оценивается в практической работе
* Названия переменных, функций и классов имеют значащие имена.
* Для вывода определённой информации используется соответствующий уровень лога.
* Для каждого модуля создаётся свой логгер.
* Созданные фильтры и обработчики переиспользуются, а не создаются в каждом модуле.
